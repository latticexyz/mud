/**
 * Parse raw `forge doc` output from contract packages, clean it up, and render as markdown in docs.
 */

import { execa } from "execa";
import prettier from "prettier";
import { readFileSync, readdirSync, writeFileSync } from "fs";
import path from "path";

const DOCS_ROOT = "next-docs/pages";

type File = {
  fileName: string;
  fileContent: string;
};

type Input = {
  source: string;
  filterFiles?: (fileName: string) => boolean;
  processContent?: (input: File) => File;
};

type PublicApis = {
  [outputFile: string]: Input[];
};

// Mapping from output file to array of input files
const PUBLIC_APIS: PublicApis = {
  "store/reference/store-core.mdx": [
    {
      source: "store/src/StoreCore.sol",
      filterFiles: (fileName) => !fileName.includes("StoreCoreInternal"),
      processContent: replaceGithubLinks,
    },
  ],
  "store/reference/store.mdx": [
    { source: "store/src/IStore.sol", processContent: replaceGithubLinks },
    { source: "store/src/IStoreData.sol", processContent: replaceGithubLinks },
    { source: "store/src/IStoreErrors.sol", processContent: replaceGithubLinks },
    { source: "store/src/IStoreEvents.sol", processContent: replaceGithubLinks },
    { source: "store/src/IStoreRead.sol", processContent: replaceGithubLinks },
    { source: "store/src/IStoreRegistration.sol", processContent: replaceGithubLinks },
  ],
  "store/reference/store-hook.mdx": [{ source: "store/src/IStoreHook.sol", processContent: replaceGithubLinks }],
};

function identity<T>(input: T): T {
  return input;
}

function replaceGithubLinks({ fileName, fileContent }: File) {
  // Find all internal Github links
  const pattern = /https:\/\/github.com\/latticexyz\/mud\/blob\/[^/]+\/(.*)/g;

  // Replace with links to `main`
  const replacement = "https://github.com/latticexyz/mud/blob/main/packages/store/$1";

  // Use the replace function
  return { fileName, fileContent: fileContent.replace(pattern, replacement) };
}

function getPackages() {
  return [
    ...new Set(
      Object.values(PUBLIC_APIS)
        .flat()
        .map((input) => input.source.split("/")[0])
    ),
  ];
}

/**
 * Generate raw docs using `forge doc` in all relevant contract packages
 */
async function generateDocs() {
  const packages = getPackages();
  for (const pkg of packages) {
    const { stdout, stderr } = await execa("forge", ["doc", "--build"], {
      stdio: "pipe",
      cwd: path.join(process.cwd(), "packages", pkg),
    });
    if (stderr || stdout) {
      console.log(stderr || stdout);
    }
  }
}

function getDocsPath(sourceFilePath: string) {
  const pkg = sourceFilePath.split("/")[0];
  const relativeFilePath = sourceFilePath.replace(pkg, "");
  return path.join("packages", pkg, "docs", "src", relativeFilePath);
}

function formatMarkdown(content: string) {
  return prettier.format(content, { parser: "markdown" });
}

/**
 * Write output files from array of input files
 */
async function renderDocs() {
  for (const [outputFile, inputFiles] of Object.entries(PUBLIC_APIS)) {
    // Concat all input files for this output file
    const content =
      `[//]: # (This file is autogenerated, do not change manually)\n\n` +
      inputFiles
        .map((input) => {
          const docsPath = getDocsPath(input.source);
          const docsFiles = readdirSync(docsPath);
          return docsFiles
            .filter(input.filterFiles ?? identity)
            .map((fileName) => ({
              fileName,
              fileContent: readFileSync(path.join(docsPath, fileName), { encoding: "utf8" }),
            }))
            .map(input.processContent ?? identity)
            .map(({ fileContent }) => fileContent);
        })
        .flat()
        .join("\n");

    // Write the output file
    writeFileSync(path.join(DOCS_ROOT, outputFile), formatMarkdown(content));
  }
}

async function run() {
  await generateDocs();
  await renderDocs();
}

await run();
