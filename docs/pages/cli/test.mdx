# mud test

This command runs the tests in a MUD project. Internally, it runs the following steps:

1. Starts an [`anvil`](https://book.getfoundry.sh/reference/anvil/) instance.
   {/* This could be either an empty blockchain, or one that can be forked for a [fork test](https://book.getfoundry.sh/forge/fork-testing). */}
1. Deploys the `World` and all related `System`s using [`mud deploy`](./deploy).
1. Runs tests using [`forge test`](https://book.getfoundry.sh/forge/tests) and passes the deployed world address to the tests via the `WORLD_ADDRESS` environment variable.

## Command line options

| Option                  | Meaning                                        | Type    | Default value                                              |
| ----------------------- | ---------------------------------------------- | ------- | ---------------------------------------------------------- |
| `--version`             | Show version number                            | boolean | `false`                                                    |
| `--configPath`          | Path to the config file                        | string  | `mud.config.ts`                                            |
| `--printConfig`         | Print the resolved config                      | boolean | `false`                                                    |
| `--saveDeployment`      | Save the deployment info to a file             | boolean | `true`                                                     |
| `--profile`             | The foundry profile to use                     | string  | `local`                                                    |
| `--srcDir`              | Source directory                               | string  | Foundry `src` directory                                    |
| `--skipBuild`           | Skip rebuilding the contracts before deploying | boolean | `false`                                                    |
| `--alwaysRunPostDeploy` | Run `PostDeploy.s.sol` after each deploy       | boolean | `false` (run the script only when deploying a new `World`) |
| `--port`                | Port for the testing `anvil` instance          | number  | 4242                                                       |
| `--help`                | Show help                                      | boolean | `false`                                                    |

## Examples

```sh copy
pnpm mud test
```

## Writing MUD tests

MUD test contracts inherit from [`MudTest`](https://github.com/latticexyz/mud/blob/main/packages/world/test/MudTest.t.sol).
This contract gets the `World` address from the `$WORLD_ADDRESS` environment variable and sets it as the `Store` address.

<details>

<summary>Line by line explanation of a simple test</summary>

This is an explanation of [the test](https://github.com/latticexyz/mud/blob/main/templates/react/packages/contracts/test/TasksTest.t.sol) for the [React template](https://github.com/latticexyz/mud/tree/main/templates/react) contracts.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.21;

import "forge-std/Test.sol";
import { MudTest } from "@latticexyz/world/test/MudTest.t.sol";
```

Import the general definitions required in all MUD tests.

```solidity
import { IWorld } from "../src/codegen/world/IWorld.sol";
import { Tasks, TasksData } from "../src/codegen/index.sol";
```

Import the definitions required for this test, the `World` we can access and the tables we'll use.

```solidity
contract TasksTest is MudTest {
  function testWorldExists() public {
```

MUD tests are [Foundry tests](https://book.getfoundry.sh/forge/tests).
Any public function that starts with `test` is a test that gets executed.

```solidity
    uint256 codeSize;
    address addr = worldAddress;
```

The `World` address comes from the [`MudTest`](https://github.com/latticexyz/mud/blob/main/packages/world/test/MudTest.t.sol#L11).

```solidity
    assembly {
      codeSize := extcodesize(addr)
    }
    assertTrue(codeSize > 0);
  }
```

Use [`extcodesize`](https://www.evm.codes/#3b?fork=shanghai) to get the size of the `World` contract.
If the deploy process failed, there wouldn't be any code there.

```solidity
  function testTasks() public {
    // Expect task to exist that we created during PostDeploy script
    TasksData memory task = Tasks.get("1");
```

Use the structure for a table entry's values that is created as part of code generation.

```solidity
    assertEq(task.description, "Walk the dog");
    assertEq(task.completedAt, 0);
```

Verify the information that is prepopulated by [the `PostDeploy.s.sol` script](https://github.com/latticexyz/mud/blob/main/templates/react/packages/contracts/script/PostDeploy.s.sol).

```solidity
    // Expect the task to be completed after calling completeTask from our TasksSystem
    IWorld(worldAddress).completeTask("1");
```

Call a `System` to modify the table data.

```solidity
    assertEq(Tasks.getCompletedAt("1"), block.timestamp);
  }
}
```

Verify that the call changed the data correctly.

</details>

<details>

<summary>A more complicated example</summary>

Here is an explanation for [the test](https://github.com/latticexyz/skystrife-public/blob/main/packages/contracts/test/MoveSystem.t.sol) for [`MoveSystem`](https://github.com/latticexyz/skystrife-public/blob/main/packages/contracts/src/systems/MoveSystem.sol) in [SkyStrife](https://skystrife.xyz/).

There are three externally available functions in this `System`:

- [`move`](https://github.com/latticexyz/skystrife-public/blob/main/packages/contracts/src/systems/MoveSystem.sol#L57-L61), used when the entity just moves.
- [`fight`](https://github.com/latticexyz/skystrife-public/blob/main/packages/contracts/src/systems/MoveSystem.sol#L63-L67), used when the entity just attacks an enemy.
- [`moveAndAttack`](https://github.com/latticexyz/skystrife-public/blob/main/packages/contracts/src/systems/MoveSystem.sol#L69-L76), used when the entity moves and then attacks an enemy.

The first test is [`testMoveOneTile`](https://github.com/latticexyz/skystrife-public/blob/main/packages/contracts/test/MoveSystem.t.sol#L67-L81):

```solidity
  function testMoveOneTile() public {
    setupMove();
```

First we use [`setupMove`](https://github.com/latticexyz/skystrife-public/blob/main/packages/contracts/test/MoveSystem.t.sol#L19-L61).
This function sets up the test by creating the player entity, the environment in which a unit could move (a 4x4 grid of grassland), the match, and a player unit that could move (whose original position is `(0,0)`).

```solidity
    PositionData[] memory path = new PositionData[](1);
    path[0] = PositionData(0, 1);
```

Create a path for the movement.

```solidity
    vm.startPrank(alice);
```

Act as `alice`, the player.

```solidity
    startGasReport("Move unit 1 tile");
    world.move(testMatch, unit, path);
    endGasReport();
```

Perform the move and generate a gas report.

```solidity
    PositionData memory position = Position.get(testMatch, unit);
    assertEq(position.x, 0, "x should be 0");
    assertEq(position.y, 1, "y should be 1");
  }
```

Verify the unit is in the correct position.

```solidity

  function testMoveTwoTiles() public {
    setupMove();

    PositionData[] memory path = new PositionData[](2);
    path[0] = PositionData(0, 1);
    path[1] = PositionData(0, 2);
    .
    .
    .
  }

  function testMoveThreeTiles() public {
    setupMove();

    PositionData[] memory path = new PositionData[](3);
    path[0] = PositionData(0, 1);
    path[1] = PositionData(0, 2);
    path[2] = PositionData(0, 3);
    .
    .
    .
  }
```

These tests are very similar to `testMoveOneTile`, except the unit moves multiple tiles (which is allowed by SkyStrife).

```solidity
function testMovementSetsLastAction() public {
  setupMove();

  PositionData[] memory path = new PositionData[](2);
  path[0] = PositionData(0, 1);
  path[1] = PositionData(0, 2);

  runSystem(path);

  uint256 lastAction = LastAction.get(testMatch, unit);
  assertEq(lastAction, block.timestamp, "last action should be the block timestamp");
}
```

This test checks that the time of the last action is updated correctly.

```solidity
function testMoveInvalidPath() public {
  setupMove();

  PositionData[] memory path = new PositionData[](2);
  path[0] = PositionData(0, 1);
  path[1] = PositionData(0, 3);

  vm.expectRevert("invalid path");
  runSystem(path);
}
```

The player may be using our client, which only sends valid paths.
However, in blockchain programming there is no such guarantee.
We _have_ to assume hostile input, so we have to test not just that actions that should be successful succeed, but also that actions that should fail fail.

</details>
