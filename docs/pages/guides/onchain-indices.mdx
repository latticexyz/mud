import { CollapseCode } from "../../components/CollapseCode";

# Onchain Indices

This guide walks through why you might need onchain indices, and how you can create and manage them.

## What are indices?

In MUD, we can answer simple queries onchain like _“what is Alice’s position?”_ with `Position.get(alice)`.

However, we often have use for more complex transformations of onchain data that are infeasible to compute onchain. For example, _“which players are at this position?”_, or _“how many gold mines does Bob own?_.

For this reason, we create onchain “indices” that maintain the result of these transformations.

## Indices in MUD

In these examples, we will make indices for a simple game where each account has an (x, y) position.

```ts filename="mud.config.ts" copy showLineNumbers
import { mudConfig } from "@latticexyz/world/register";

export default mudConfig({
  tables: {
    Position: {
      keySchema: {
        player: "address",
      },
      valueSchema: {
        x: "int32",
        y: "int32",
      },
    },
  },
});
```

In this game, players update their position by calling `MoveSystem.move` with their desired coordinates.

```solidity filename="MoveSystem.sol" copy showLineNumbers
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { System } from "@latticexyz/world/src/System.sol";
import { Position } from "../codegen/index.sol";

contract MoveSystem is System {
  function move(int32 x, int32 y) public {
    address player = _msgSender();

    Position.set(player, x, y);
  }
}
```

To make the game more interesting, we would like to prevent players from moving to positions that are already occupied. However, it's not clear how to tell which players are at a given position onchain.

   <CollapseCode>

```solidity filename="MoveSystem.sol" copy showLineNumbers {11-14}
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { System } from "@latticexyz/world/src/System.sol";
import { Position } from "../codegen/index.sol";

contract MoveSystem is System {
  function move(int32 x, int32 y) public {
    address player = _msgSender();

    bool positionIsEmpty = ?
    require(positionIsEmpty, "another player is at this position");

    Position.set(player, x, y);
  }
}
```

   </CollapseCode>

In other words, there is no reverse mapping - we can read the position of a given player, but not which players are at each position. It's time to add an index!

There are two main ways to implement this - you can **create and manage your own indices**, or **use a module**.

### Creating your own indices

#### `PlayersAtPosition`

One way to know whether a position is occupied is to have a list of which players are there, and check if that list is empty.

First, we declare an `PlayersAtPosition` table in our MUD config. The schema is essentially the reverse of `Position`; the key is an (x, y) coordinate and the value is an array of addresses currently at that position:

   <CollapseCode>
```ts filename="mud.config.ts" copy showLineNumbers {14-17}
import { mudConfig } from "@latticexyz/world/register";

export default mudConfig({
  tables: {
    Position: {
      keySchema: {
        player: "address",
      },
      valueSchema: {
        x: "int32",
        y: "int32",
      },
    },
    PlayersAtPosition: {
      keySchema: { x: "int32", y: "int32" },
      valueSchema: { players: "address[]" },
    },
  },
});
```

  </CollapseCode>

With our own indices, we need to be careful that they are maintained whenever the relevant tables are updated. Otherwise, they will not reflect current store data (for example, players in a `PlayersInPosition` list that don't actually have that `Position` value).

In this case, we need to add or remove addresses from `PlayersAtPosition` whenever a position is set. A good practice for this is to write a helper that atomically sets the table and index.

We can use a `setPosition` helper function to set both `Position` and the index.

```solidity filename="setPosition.sol" copy showLineNumbers
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { Position, PositionData, PlayersAtPosition } from "../codegen/index.sol";

function filter(address[] memory arr, address element) pure returns (address[] memory) {
  address[] memory filtered = new address[](arr.length);
  uint256 filteredIndex;
  for (uint256 i; i < arr.length; i++) {
    if (arr[i] != element) {
      filtered[filteredIndex] = arr[i];
      filteredIndex++;
    }
  }

  // In-place update the length of the array
  // (Note: this does not update the free memory pointer)
  assembly {
    mstore(filtered, filteredIndex)
  }

  return filtered;
}

function setPosition(address player, int32 x, int32 y) {
  // Get the player's previous position
  PositionData memory previousPosition = Position.get(player);

  // Remove the player from the index for the previous position
  PlayersAtPosition.set(
    previousPosition.x,
    previousPosition.y,
    filter(PlayersAtPosition.get(previousPosition.x, previousPosition.y), player)
  );

  // Push the player to the index for the new position
  PlayersAtPosition.push(x, y, player);

  // Set the players position
  Position.set(player, x, y);
}
```

Then, we use `setPosition` instead of `Position.set` any time that we change a `Position`:

   <CollapseCode>

```solidity filename="MoveSystem.sol" copy showLineNumbers {5,11}
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { System } from "@latticexyz/world/src/System.sol";
import { setPosition } from "./setPosition.sol";

contract MoveSystem is System {
  function move(int32 x, int32 y) public {
    address player = _msgSender();

    setPosition(player, x, y);
  }
}
```

   </CollapseCode>

Finally, before moving, we can check whether `PlayersAtPosition` is empty for the given position.

   <CollapseCode>

```solidity filename="MoveSystem.sol" copy showLineNumbers {6,12-13}
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { System } from "@latticexyz/world/src/System.sol";
import { setPosition } from "./setPosition.sol";
import { PlayersAtPosition } from "../codegen/index.sol";

contract MoveSystem is System {
  function move(int32 x, int32 y) public {
    address player = _msgSender();

    bool positionIsEmpty = PlayersAtPosition.length(x, y) == 0;
    require(positionIsEmpty, "another player is at this position");

    setPosition(player, x, y);
  }
}
```

   </CollapseCode>

#### `PositionIsOccupied`

Having a list of players at each position is useful, but ultimately we only want to know if _some_ player is at the position, not their specific addresses. In addition, the "occupied" check ensures that at most one player can be at a given position.

Therefore we can take advantage of managing this in our own contracts and write a simpler index.

This time, we declare a table called `PositionIsOccupied`:

   <CollapseCode>
```ts filename="mud.config.ts" copy showLineNumbers {14-22}
import { mudConfig } from "@latticexyz/world/register";

export default mudConfig({
  tables: {
    Position: {
      keySchema: {
        player: "address",
      },
      valueSchema: { 
        x: "int32", 
        y: "int32" 
      },
    },
    PositionIsOccupied: {
      keySchema: { 
        x: "int32", 
        y: "int32"
      },
      valueSchema: { 
        isOccupied: "bool" 
      },
    }
  }
});
```

  </CollapseCode>

To maintain this index when players move, we flag the previous position as empty and the new one as occupied.

```solidity filename="setPosition.sol" copy showLineNumbers
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { Position, PositionData, PositionIsOccupied } from "../codegen/index.sol";

function setPosition(address player, int32 x, int32 y) {
  // Cache the player's previous position
  PositionData memory previousPosition = Position.get(player);

  Position.set(player, x, y);

  PositionIsOccupied.set(previousPosition.x, previousPosition.y, false);
  PositionIsOccupied.set(x, y, true);
}
```

Finally, to check whether the position is occupied, we simply read the index.

   <CollapseCode>

```solidity filename="MoveSystem.sol" copy showLineNumbers {5,11}
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { System } from "@latticexyz/world/src/System.sol";
import { Position, PositionIsOccupied } from "../codegen/index.sol";

contract MoveSystem is System {
  function move(int32 x, int32 y) public {
    address player = _msgSender();

    bool positionIsEmpty = !PositionIsOccupied.get(x, y);
    require(positionIsEmpty, "another player is at this position");

    Position.set(player, x, y);
  }
}
```

   </CollapseCode>

### Using modules

#### `KeysWithValue`

We can also use a [Module](/world/modules) to install and manage an index for us. The [`KeysWithValue`](/world/modules/keyswithvalue) module can be installed on tables and maintains an array of keys with each value.

In this case, we install it for the `Position` table, in the `modules` property of the MUD config:

   <CollapseCode>
```ts filename="mud.config.ts" copy showLineNumbers {12-18}
import { mudConfig } from "@latticexyz/world/register";

export default mudConfig({
	tables: {
		Position: {
		  keySchema: {
		    player: "address",
		  },
		  valueSchema: { x: "int32", y: "int32" },
		}
	},
  modules: [
    {
      name: "KeysWithValueModule",
      root: true,
      args: [resolveTableId("Position")],
    },
  ],
}
```

  </CollapseCode>

Internally, this module uses [Store Hooks](https://mud.dev/store/store-hooks) to automatically update the index whenever a `Position` record is set.

After the module is installed, we can use a helper to get all addresses at a given position:

```solidity filename="MoveSystem.sol" copy showLineNumbers {4,6-7,13-18}
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { PackedCounter } from "@latticexyz/store/src/PackedCounter.sol";
import { System } from "@latticexyz/world/src/System.sol";
import { getKeysWithValue } from "@latticexyz/world-modules/src/modules/keyswithvalue/getKeysWithValue.sol";
import { Position, PositionTableId } from "../codegen/index.sol";

contract MoveSystem is System {
  function move(int32 x, int32 y) public {
    address player = _msgSender();

    bool positionIsEmpty = getKeysWithValue(
      PositionTableId,
      Position.encodeStatic(x, y),
      PackedCounter.wrap(bytes32(0)),
      ""
    ).length == 0;
    require(positionIsEmpty, "another player is at this position");

    Position.set(player, x, y);
  }
}
```

### Gas comparison

With MUD's [`GasReporter`](https://github.com/latticexyz/mud/tree/main/packages/gas-report), we can determine the gas use of `MoveSystem.move`:

```solidity filename="MoveSystem.t.sol" copy showLineNumbers
// SPDX-License-Identifier: MIT
pragma solidity >=0.8.24;

import { MudTest } from "@latticexyz/world/test/MudTest.t.sol";
import { GasReporter } from "@latticexyz/gas-report/src/GasReporter.sol";

import { IWorld } from "../src/codegen/world/IWorld.sol";

contract MoveSystemTest is MudTest, GasReporter {
  function testMove() public {
    startGasReport("moving one player");
    IWorld(worldAddress).move(1, 1);
    endGasReport();
  }
}
```

Comparing the three approaches, we find that managing our own indices is generally more gas-efficient, with the "position is occupied" index being the cheapest by far.

#### `PlayersAtPosition`

```
┌───────────────────────┬──────────┬───────────────────┬──────────┐
│ File                  │ Test     │ Name              │ Gas used │
├───────────────────────┼──────────┼───────────────────┼──────────┤
│ test/MoveSystem.t.sol │ testMove │ moving one player │ 135922   │
└───────────────────────┴──────────┴───────────────────┴──────────┘
```

#### `PositionIsOccupied`

```
┌───────────────────────┬──────────┬───────────────────┬──────────┐
│ File                  │ Test     │ Name              │ Gas used │
├───────────────────────┼──────────┼───────────────────┼──────────┤
│ test/MoveSystem.t.sol │ testMove │ moving one player │ 64637    │
└───────────────────────┴──────────┴───────────────────┴──────────┘
```

#### `KeysWithValue`

```
┌───────────────────────┬──────────┬───────────────────┬──────────┐
│ File                  │ Test     │ Name              │ Gas used │
├───────────────────────┼──────────┼───────────────────┼──────────┤
│ test/MoveSystem.t.sol │ testMove │ moving one player │ 165000   │
└───────────────────────┴──────────┴───────────────────┴──────────┘
```
