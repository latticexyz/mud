// SPDX-License-Identifier: MIT
pragma solidity >=0.8.0;

import { TightCoder } from "./TightCoder.sol";
import { Slice } from "../Slice.sol";
import { SchemaType } from "../Types.sol";

library DecodeSlice {
  /************************************************************************
   *
   *    uint8 - uint256
   *
   ************************************************************************/
<% for (let i = 8; i <= 256; i += 8) { -%>

  function decodeArray_uint<%= i %>(Slice self) internal pure returns (uint<%= i %>[] memory output) {
    bytes32[] memory genericArray = TightCoder.decode(self, <%= i / 8 %>, false);
    assembly {
      output := genericArray
    }
  }
<% } -%>

  /************************************************************************
   *
   *    int8 - int256
   *
   ************************************************************************/
<% for (let i = 8; i <= 256; i += 8) { -%>

  function decodeArray_int<%= i %>(Slice self) internal pure returns (int<%= i %>[] memory output) {
    bytes32[] memory genericArray = TightCoder.decode(self, <%= i / 8 %>, false);
    assembly {
      output := genericArray
    }
  }
<% } -%>

  /************************************************************************
   *
   *    bytes1 - bytes32
   *
   ************************************************************************/
<% for (let i = 1; i <= 32; i += 1) { -%>

  function decodeArray_bytes<%= i %>(Slice self) internal pure returns (bytes<%= i %>[] memory output) {
    bytes32[] memory genericArray = TightCoder.decode(self, <%= i %>, true);
    assembly {
      output := genericArray
    }
  }
<% } -%>

  /************************************************************************
   *
   *    Other types
   *
   ************************************************************************/

  function decodeArray_address(Slice self) internal pure returns (address[] memory output) {
    // Note: internally address is right-aligned, like uint160
    bytes32[] memory genericArray = TightCoder.decode(self, 20, false);
    assembly {
      output := genericArray
    }
  }

  function decodeArray_bool(Slice self) internal pure returns (bool[] memory output) {
    bytes32[] memory genericArray = TightCoder.decode(self, 1, false);
    assembly {
      output := genericArray
    }
  }

  function decodeArray_SchemaType(Slice self) internal pure returns (SchemaType[] memory output) {
    bytes32[] memory genericArray = TightCoder.decode(self, 1, false);
    assembly {
      output := genericArray
    }
  }
}
