import path from "path";
import {
  AbsoluteImportDatum,
  RelativeImportDatum,
  ImportDatum,
  StaticResourceData,
  RenderKeyTuple,
  RenderType,
} from "./types";
import { posixPath } from "../utils";

export const renderedSolidityHeader = `// SPDX-License-Identifier: MIT
pragma solidity >=0.8.21;

/* Autogenerated file. Do not edit manually. */`;

/**
 * Renders a list of lines
 */
export function renderList<T>(list: T[], renderItem: (item: T, index: number) => string): string {
  return internalRenderList("", list, renderItem);
}

/**
 * Renders a comma-separated list of arguments for solidity functions, ignoring empty and undefined ones
 */
export function renderArguments(args: (string | undefined)[]): string {
  const filteredArgs = args.filter((arg) => arg !== undefined && arg !== "") as string[];
  return internalRenderList(",", filteredArgs, (arg) => arg);
}

export function renderCommonData({
  staticResourceData,
  keyTuple,
}: {
  staticResourceData?: StaticResourceData;
  keyTuple: RenderKeyTuple[];
}): {
  _typedTableId: string;
  _typedKeyArgs: string;
  _keyTupleDefinition: string;
} {
  // static resource means static tableId as well, and no tableId arguments
  const _typedTableId = staticResourceData ? "" : "ResourceId _tableId";
  const _typedKeyArgs = renderArguments(keyTuple.map(({ name, typeWithLocation }) => `${typeWithLocation} ${name}`));

  const _keyTupleDefinition = `
    bytes32[] memory _keyTuple = new bytes32[](${keyTuple.length});
    ${renderList(keyTuple, (key, index) => `_keyTuple[${index}] = ${renderValueTypeToBytes32(key.name, key)};`)}
  `;

  return {
    _typedTableId,
    _typedKeyArgs,
    _keyTupleDefinition,
  };
}

/** For 2 paths which are relative to a common root, create a relative import path from one to another */
export function solidityRelativeImportPath(fromPath: string, usedInPath: string): string {
  // 1st "./" must be added because path strips it,
  // but solidity expects it unless there's "../" ("./../" is fine).
  // 2nd and 3rd "./" forcefully avoid absolute paths (everything is relative to `src`).
  return posixPath("./" + path.relative("./" + usedInPath, "./" + fromPath));
}

/**
 * Aggregates, deduplicates and renders imports for symbols per path.
 * Identical symbols from different paths are NOT handled, they should be checked before rendering.
 */
export function renderImports(imports: ImportDatum[]): string {
  return renderAbsoluteImports(
    imports.map((importDatum) => {
      if ("path" in importDatum) {
        return importDatum;
      } else {
        return {
          symbol: importDatum.symbol,
          path: solidityRelativeImportPath(importDatum.fromPath, importDatum.usedInPath),
        };
      }
    })
  );
}

/**
 * Aggregates, deduplicates and renders imports for symbols per path.
 * Identical symbols from different paths are NOT handled, they should be checked before rendering.
 */
export function renderRelativeImports(imports: RelativeImportDatum[]): string {
  return renderAbsoluteImports(
    imports.map(({ symbol, fromPath, usedInPath }) => ({
      symbol,
      path: solidityRelativeImportPath(fromPath, usedInPath),
    }))
  );
}

/**
 * Aggregates, deduplicates and renders imports for symbols per path.
 * Identical symbols from different paths are NOT handled, they should be checked before rendering.
 */
export function renderAbsoluteImports(imports: AbsoluteImportDatum[]): string {
  // Aggregate symbols by import path, also deduplicating them
  const aggregatedImports = new Map<string, Set<string>>();
  for (const { symbol, path } of imports) {
    if (!aggregatedImports.has(path)) {
      aggregatedImports.set(path, new Set());
    }
    aggregatedImports.get(path)?.add(symbol);
  }
  // Render imports
  const renderedImports = [];
  for (const [path, symbols] of aggregatedImports) {
    const renderedSymbols = [...symbols].join(", ");
    renderedImports.push(`import { ${renderedSymbols} } from "${posixPath(path)}";`);
  }
  return renderedImports.join("\n");
}

export function renderWithStore(
  storeArgument: boolean,
  callback: (data: {
    _typedStore: string | undefined;
    _store: string;
    _commentSuffix: string;
    _methodNamePrefix: string;
    _internal?: boolean;
  }) => string
): string {
  let result = "";
  result += callback({ _typedStore: undefined, _store: "StoreSwitch", _commentSuffix: "", _methodNamePrefix: "" });
  result += callback({
    _typedStore: undefined,
    _store: "StoreCore",
    _commentSuffix: "",
    _methodNamePrefix: "_",
    _internal: true,
  });

  if (storeArgument) {
    result +=
      "\n" +
      callback({
        _typedStore: "IStore _store",
        _store: "_store",
        _commentSuffix: " (using the specified store)",
        _methodNamePrefix: "",
      });
  }

  return result;
}

export function renderWithFieldSuffix(
  withSuffixlessFieldMethods: boolean,
  fieldName: string,
  callback: (_methodNameSuffix: string) => string
): string {
  const methodNameSuffix = `${fieldName[0].toUpperCase()}${fieldName.slice(1)}`;
  let result = "";
  result += callback(methodNameSuffix);

  if (withSuffixlessFieldMethods) {
    result += "\n" + callback("");
  }

  return result;
}

export function renderTableId({ namespace, name, offchainOnly, tableIdName }: StaticResourceData): {
  hardcodedTableId: string;
  tableIdDefinition: string;
} {
  const hardcodedTableId = `
    ResourceId.wrap(
      bytes32(
        abi.encodePacked(
          ${offchainOnly ? "RESOURCE_OFFCHAIN_TABLE" : "RESOURCE_TABLE"},
          bytes14("${namespace}"),
          bytes16("${name}")
        )
      )
    )
  `;

  const tableIdDefinition = `
    ResourceId constant _tableId = ${hardcodedTableId};
    ResourceId constant ${tableIdName} = _tableId;
  `;
  return {
    hardcodedTableId,
    tableIdDefinition,
  };
}

export function renderValueTypeToBytes32(name: string, { typeUnwrap, internalTypeId }: RenderType): string {
  const innerText = typeUnwrap.length ? `${typeUnwrap}(${name})` : name;

  if (internalTypeId === "bytes32") {
    return innerText;
  } else if (/^bytes\d{1,2}$/.test(internalTypeId)) {
    return `bytes32(${innerText})`;
  } else if (/^uint\d{1,3}$/.test(internalTypeId)) {
    return `bytes32(uint256(${innerText}))`;
  } else if (/^int\d{1,3}$/.test(internalTypeId)) {
    return `bytes32(uint256(int256(${innerText})))`;
  } else if (internalTypeId === "address") {
    return `bytes32(uint256(uint160(${innerText})))`;
  } else if (internalTypeId === "bool") {
    return `_boolToBytes32(${innerText})`;
  } else {
    throw new Error(`Unknown value type id ${internalTypeId}`);
  }
}

export function isLeftAligned(field: Pick<RenderType, "internalTypeId">): boolean {
  return /^bytes\d{1,2}$/.test(field.internalTypeId);
}

export function getLeftPaddingBits(field: Pick<RenderType, "internalTypeId" | "staticByteLength">): number {
  if (isLeftAligned(field)) {
    return 0;
  } else {
    return 256 - field.staticByteLength * 8;
  }
}

function internalRenderList<T>(
  lineTerminator: string,
  list: T[],
  renderItem: (item: T, index: number) => string
): string {
  return list
    .map((item, index) => renderItem(item, index) + (index === list.length - 1 ? "" : lineTerminator))
    .join("\n");
}
