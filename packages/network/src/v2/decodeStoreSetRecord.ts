import { TableId, arrayToHex } from "@latticexyz/utils";
import { Contract, utils } from "ethers";
import { registerSchema } from "./schemas/tableSchemas";
import { registerMetadata } from "./schemas/tableMetadata";
import { decodeData } from "./schemas/decodeData";
import { schemaTableId, metadataTableId } from "./common";

export async function decodeStoreSetRecord(
  contract: Contract,
  table: TableId,
  keyTuple: string[],
  data: string
): Promise<{ indexedValues: Record<number, any>; namedValues?: Record<string, any> }> {
  // registerSchema event
  if (table.toHexString() === schemaTableId.toHexString()) {
    const [tableForSchema, ...otherKeys] = keyTuple;
    if (otherKeys.length) {
      console.warn(
        "registerSchema event has more than one value in key tuple, but this method only supports a single key",
        { table, keyTuple }
      );
    }
    registerSchema(contract, TableId.fromBytes32(utils.arrayify(tableForSchema)), data);
  }

  const schema = await registerSchema(contract, table);
  const indexedValues = decodeData(schema, data);

  if (table.toHexString() === metadataTableId.toHexString()) {
    const [tableForMetadata, ...otherKeys] = keyTuple;
    if (otherKeys.length) {
      console.warn(
        "setMetadata event has more than one value in key tuple, but this method only supports a single key",
        { table, keyTuple }
      );
    }
    const tableName = indexedValues[0];
    const [fieldNames] = utils.defaultAbiCoder.decode(["string[]"], indexedValues[1]);
    registerMetadata(contract, TableId.fromBytes32(utils.arrayify(tableForMetadata)), { tableName, fieldNames });
  }

  const metadata = await registerMetadata(contract, table);
  if (metadata) {
    const { tableName, fieldNames } = metadata;
    const namedValues: Record<string, any> = {};
    for (const [index, fieldName] of fieldNames.entries()) {
      namedValues[fieldName] = indexedValues[index];
    }
    return {
      indexedValues,
      namedValues,
    };
  }

  console.warn(
    `Received data for ${table.toString()}, but could not find table metadata for field names. Did your contracts get autogenerated and deployed properly?`
  );
  return {
    indexedValues,
  };
}
