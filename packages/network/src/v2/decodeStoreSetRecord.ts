import { TableId } from "@latticexyz/utils";
import { Contract, utils } from "ethers";
import { registerSchema } from "./schemas/tableSchemas";
import { registerMetadata } from "./schemas/tableMetadata";
import { decodeData } from "./schemas/decodeData";
import { schemaTableId, metadataTableId } from "./common";
import { decodeKeyTuple } from "./schemas/decodeKeyTuple";

export async function decodeStoreSetRecord(
  contract: Contract,
  table: TableId,
  keyTuple: string[],
  data: string
): Promise<{
  indexedValues: Record<number, any>;
  namedValues?: Record<string, any>;
  indexedKey: Record<number, unknown>;
  namedKey?: Record<string, unknown>;
}> {
  // registerSchema event
  if (table.toHexString() === schemaTableId.toHexString()) {
    const [tableForSchema, ...otherKeys] = keyTuple;
    if (otherKeys.length) {
      console.warn(
        "registerSchema event has more than one value in key tuple, but this method only supports a single key",
        { table, keyTuple }
      );
    }
    registerSchema(contract, TableId.fromBytes32(utils.arrayify(tableForSchema)), data);
  }

  const { keySchema, valueSchema } = await registerSchema(contract, table);
  const indexedValues = decodeData(valueSchema, data);
  const indexedKey = decodeKeyTuple(keySchema, keyTuple);

  if (table.toHexString() === metadataTableId.toHexString()) {
    const [tableForMetadata, ...otherKeys] = keyTuple;
    if (otherKeys.length) {
      console.warn(
        "setMetadata event has more than one value in key tuple, but this method only supports a single key",
        { table, keyTuple }
      );
    }
    const tableName = indexedValues[0];
    const [fieldNames] = utils.defaultAbiCoder.decode(["string[]"], indexedValues[1]);
    registerMetadata(contract, TableId.fromBytes32(utils.arrayify(tableForMetadata)), { tableName, fieldNames });
  }

  const metadata = await registerMetadata(contract, table);
  if (metadata) {
    const { tableName, fieldNames } = metadata;
    const namedValues: Record<string, any> = {};
    for (const [index, fieldName] of fieldNames.entries()) {
      namedValues[fieldName] = indexedValues[index];
    }

    // TODO: once TableMetadata supports key names we can decode them here.
    // For now we extract the key names of known tables from the `mud.config.ts`
    // and ignore others in `applyNetworkUpdate`.
    // (see https://github.com/latticexyz/mud/issues/824)

    return {
      indexedValues,
      namedValues,
      indexedKey,
    };
  }

  console.warn(
    `Received data for ${table.toString()}, but could not find table metadata for field names. Did your contracts get autogenerated and deployed properly?`
  );
  return {
    indexedValues,
    indexedKey,
  };
}
