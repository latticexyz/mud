{"version":3,"sources":["../src/createNetwork.ts","../src/createSigner.ts","../src/createClock.ts","../src/createContracts.ts","../src/createTxQueue.ts","../src/createSyncWorker.ts","../src/createTopics.ts","../src/createDecoder.ts","../src/createEncoder.ts","../src/createSystemExecutor.ts","../src/createRelayStream.ts","../src/createFaucetService.ts","../src/createFastTxExecutor.ts","../src/v2/snapSync/getSnapSyncRecords.ts","../src/v2/snapSync/snapSyncSystemAbi.ts"],"sourcesContent":["import { computed, observable, toJS } from \"mobx\";\nimport { createSigner } from \"./createSigner\";\nimport { createReconnectingProvider } from \"./createProvider\";\nimport { NetworkConfig } from \"./types\";\nimport { combineLatest, concatMap, EMPTY, filter, map, throttleTime } from \"rxjs\";\nimport { createClock } from \"./createClock\";\nimport { fetchBlock } from \"./networkUtils\";\nimport { createBlockNumberStream } from \"./createBlockNumberStream\";\nimport { Signer, Wallet } from \"ethers\";\nimport { computedToStream } from \"@latticexyz/utils\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport { Address, fallback, webSocket, http, createPublicClient, createWalletClient, Chain } from \"viem\";\nimport * as mudChains from \"@latticexyz/common/chains\";\nimport * as chains from \"viem/chains\";\nimport * as devObservables from \"./dev/observables\";\n\nexport type Network = Awaited<ReturnType<typeof createNetwork>>;\n\n/**\n * Set up network.\n *\n * @param initialConfig Initial config (see {@link NetworkConfig}).\n * @returns Network object\n */\nexport async function createNetwork(initialConfig: NetworkConfig) {\n  const config = observable(initialConfig);\n  const disposers: (() => void)[] = [];\n  const {\n    providers,\n    connected,\n    dispose: disposeProvider,\n  } = await createReconnectingProvider(computed(() => toJS(config.provider)));\n  disposers.push(disposeProvider);\n\n  // Create signer\n  const signer = computed<Signer | undefined>(() => {\n    const currentProviders = providers.get();\n    if (config.provider.externalProvider) return currentProviders.json.getSigner();\n    const privateKey = config.privateKey;\n    if (privateKey && currentProviders) return createSigner(privateKey, currentProviders);\n  });\n\n  // Get address\n  const initialConnectedAddress = config.provider.externalProvider ? await signer.get()?.getAddress() : undefined;\n  const connectedAddress = computed(() =>\n    config.privateKey ? new Wallet(config.privateKey).address.toLowerCase() : initialConnectedAddress?.toLowerCase()\n  );\n  const connectedAddressChecksummed = computed(() =>\n    config.privateKey ? new Wallet(config.privateKey).address : initialConnectedAddress\n  );\n\n  // Listen to new block numbers\n  const { blockNumber$, dispose: disposeBlockNumberStream } = createBlockNumberStream(providers);\n  disposers.push(disposeBlockNumberStream);\n\n  // Create local clock\n  const clock = createClock(config.clock);\n  disposers.push(clock.dispose);\n\n  // Sync the local time to the chain time in regular intervals\n  const syncBlockSub = combineLatest([blockNumber$, computedToStream(providers)])\n    .pipe(\n      throttleTime(config.clock.syncInterval, undefined, { leading: true, trailing: true }),\n      concatMap(([blockNumber, currentProviders]) =>\n        currentProviders ? fetchBlock(currentProviders.json, blockNumber) : EMPTY\n      ), // Fetch the latest block if a provider is available\n      map((block) => block.timestamp * 1000), // Map to timestamp in ms\n      filter((blockTimestamp) => blockTimestamp !== clock.lastUpdateTime), // Ignore if the clock was already refreshed with this block\n      filter((blockTimestamp) => blockTimestamp !== clock.currentTime) // Ignore if the current local timestamp is correct\n    )\n    .subscribe(clock.update); // Update the local clock\n  disposers.push(() => syncBlockSub?.unsubscribe());\n\n  // Create viem clients\n  try {\n    const possibleChains = Object.values({ ...mudChains, ...chains }) as Chain[];\n    if (config.chainConfig) {\n      possibleChains.unshift(config.chainConfig);\n    }\n    const chain = possibleChains.find((c) => c.id === config.chainId);\n    if (!chain) {\n      throw new Error(`No chain found for chain ID ${config.chainId}`);\n    }\n\n    const publicClient = createPublicClient({\n      chain,\n      transport: fallback([webSocket(), http()]),\n      pollingInterval: config.provider.options?.pollingInterval ?? config.clock.period ?? 1000,\n    });\n    const burnerAccount = config.privateKey ? privateKeyToAccount(config.privateKey as Address) : null;\n    const burnerWalletClient = burnerAccount\n      ? createWalletClient({\n          account: burnerAccount,\n          chain,\n          transport: fallback([webSocket(), http()]),\n          pollingInterval: config.provider.options?.pollingInterval ?? config.clock.period ?? 1000,\n        })\n      : null;\n\n    devObservables.publicClient$.next(publicClient);\n    devObservables.walletClient$.next(burnerWalletClient);\n  } catch (error) {\n    console.error(\"Could not initialize viem clients, dev tools may not work:\", error);\n  }\n\n  return {\n    providers,\n    signer,\n    connected,\n    blockNumber$,\n    dispose: () => {\n      for (const disposer of disposers) disposer();\n    },\n    clock,\n    config,\n    connectedAddress,\n    connectedAddressChecksummed,\n    // TODO: TS complains about exporting these, figure out why\n    // publicClient,\n    // burnerWalletClient,\n  };\n}\n","import { Wallet } from \"ethers\";\nimport { Providers } from \"./createProvider\";\n\nexport function createSigner(privateKey: string, providers: Providers) {\n  return new Wallet(privateKey, providers.json);\n}\n","import { ReplaySubject } from \"rxjs\";\nimport { Clock, ClockConfig } from \"./types\";\n\n/**\n * Create a clock optimistically keeping track of the current chain time.\n * The optimisitic chain time should be synced to the actual chain time in regular intervals using the `update` function.\n *\n * @param config\n * @returns: {@link Clock}\n */\nexport function createClock(config: ClockConfig): Clock {\n  const { initialTime, period } = config;\n\n  const clock = {\n    currentTime: initialTime,\n    lastUpdateTime: initialTime,\n    time$: new ReplaySubject<number>(1),\n    dispose: () => clearInterval(intervalId),\n    update,\n  };\n\n  let intervalId = createTickInterval();\n  emit();\n\n  function emit() {\n    clock.time$.next(clock.currentTime);\n  }\n\n  function createTickInterval() {\n    return setInterval(() => {\n      clock.currentTime += period;\n      emit();\n    }, period);\n  }\n\n  function update(time: number) {\n    clearInterval(intervalId);\n    clock.currentTime = time;\n    clock.lastUpdateTime = time;\n    emit();\n    intervalId = createTickInterval();\n  }\n\n  return clock;\n}\n","import { Contracts, ContractsConfig } from \"./types\";\nimport { Contract, Signer } from \"ethers\";\nimport { Provider } from \"@ethersproject/providers\";\nimport { computed, IComputedValue } from \"mobx\";\nimport { mapObject } from \"@latticexyz/utils\";\n\n/**\n * Create an object of contracts connected to the currently connected provider.\n *\n * @param config: {@link ContractsConfig}\n * @returns Object with contracts connected to the currently connected provider.\n */\nexport async function createContracts<C extends Contracts>({\n  config,\n  asyncConfig,\n  signerOrProvider,\n}: {\n  config: Partial<ContractsConfig<C>>;\n  asyncConfig?: (contracts: C) => Promise<Partial<ContractsConfig<C>>>;\n  signerOrProvider: IComputedValue<Signer | Provider>;\n}): Promise<{ contracts: IComputedValue<C>; config: ContractsConfig<C> }> {\n  const contracts = computed(() =>\n    mapObject<Partial<ContractsConfig<C>>, C>(\n      config,\n      (c) => c && (new Contract(c.address, c.abi, signerOrProvider.get()) as C[keyof C])\n    )\n  );\n\n  if (!asyncConfig) return { contracts, config: config as ContractsConfig<C> };\n\n  const asyncConfigResult = await asyncConfig(contracts.get());\n\n  const asyncContracts = computed(() =>\n    mapObject<Partial<ContractsConfig<C>>, C>(\n      asyncConfigResult,\n      (c) => c && (new Contract(c.address, c.abi, signerOrProvider.get()) as C[keyof C])\n    )\n  );\n\n  return {\n    contracts: computed(() => ({ ...contracts.get(), ...asyncContracts.get() })),\n    config: { ...config, ...asyncConfigResult } as ContractsConfig<C>,\n  };\n}\n","/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { BaseContract, BigNumberish, CallOverrides, Overrides } from \"ethers\";\nimport { autorun, computed, IComputedValue, IObservableValue, observable, runInAction } from \"mobx\";\nimport { mapObject, deferred, uuid, awaitValue, cacheUntilReady } from \"@latticexyz/utils\";\nimport { Mutex } from \"async-mutex\";\nimport { JsonRpcProvider, TransactionReceipt } from \"@ethersproject/providers\";\nimport { Contracts, TxQueue } from \"./types\";\nimport { ConnectionState } from \"./createProvider\";\nimport { Network } from \"./createNetwork\";\nimport { getRevertReason } from \"./networkUtils\";\nimport { BehaviorSubject } from \"rxjs\";\n\ntype ReturnTypeStrict<T> = T extends (...args: any) => any ? ReturnType<T> : never;\n\n/**\n * The TxQueue takes care of nonce management, concurrency and caching calls if the contracts are not connected.\n * Cached calls are passed to the queue once the contracts are available.\n *\n * @param computedContracts A computed object containing the contracts to be channelled through the txQueue\n * @param network A network object containing provider, signer, etc\n * @param options The concurrency declares how many transactions can wait for confirmation at the same time.\n * @returns TxQueue object\n */\nexport function createTxQueue<C extends Contracts>(\n  computedContracts: IComputedValue<C> | IObservableValue<C>,\n  network: Network,\n  gasPrice$: BehaviorSubject<number>,\n  options?: { concurrency?: number; devMode?: boolean }\n): { txQueue: TxQueue<C>; dispose: () => void; ready: IComputedValue<boolean | undefined> } {\n  const { concurrency } = options || {};\n\n  const queue = createPriorityQueue<{\n    execute: (\n      nonce: number,\n      gasLimit: BigNumberish\n    ) => Promise<{ hash: string; wait: () => Promise<TransactionReceipt> }>;\n    estimateGas: () => BigNumberish | Promise<BigNumberish>;\n    cancel: (error: any) => void;\n    stateMutability?: string;\n  }>();\n  const submissionMutex = new Mutex();\n  const _nonce = observable.box<number | null>(null);\n\n  const readyState = computed(() => {\n    const connected = network.connected.get();\n    const contracts = computedContracts.get();\n    const signer = network.signer.get();\n    const provider = network.providers.get()?.json;\n    const nonce = _nonce.get();\n\n    if (connected !== ConnectionState.CONNECTED || !contracts || !signer || !provider || nonce == null)\n      return undefined;\n\n    return { contracts, signer, provider, nonce };\n  });\n\n  let utilization = 0;\n\n  async function resetNonce() {\n    runInAction(() => _nonce.set(null));\n    const newNonce = (await network.signer.get()?.getTransactionCount()) ?? null;\n    runInAction(() => _nonce.set(newNonce));\n  }\n\n  // Set the nonce on init and reset if the signer changed\n  const dispose = autorun(resetNonce);\n\n  function incNonce() {\n    runInAction(() => {\n      const currentNonce = _nonce.get();\n      const newNonce = currentNonce == null ? null : currentNonce + 1;\n      _nonce.set(newNonce);\n    });\n  }\n\n  function queueCall(\n    target: C[keyof C],\n    prop: keyof C[keyof C],\n    args: unknown[]\n  ): Promise<{\n    hash: string;\n    wait: () => Promise<TransactionReceipt>;\n    response: Promise<ReturnTypeStrict<(typeof target)[typeof prop]>>;\n  }> {\n    const [resolve, reject, promise] = deferred<{\n      hash: string;\n      wait: () => Promise<TransactionReceipt>;\n      response: Promise<ReturnTypeStrict<(typeof target)[typeof prop]>>;\n    }>();\n\n    // Extract existing overrides from function call\n    const hasOverrides = args.length > 0 && isOverrides(args[args.length - 1]);\n    const overrides = (hasOverrides ? args[args.length - 1] : {}) as CallOverrides;\n    const argsWithoutOverrides = hasOverrides ? args.slice(0, args.length - 1) : args;\n\n    // Store state mutability to know when to increase the nonce\n    const fragment = target.interface.fragments.find((fragment) => fragment.name === prop);\n    const stateMutability = fragment && (fragment as { stateMutability?: string }).stateMutability;\n\n    // Create a function that estimates gas if no gas is provided\n    const gasLimit = overrides[\"gasLimit\"];\n    const estimateGas = gasLimit == null ? () => target.estimateGas[prop as string](...args) : () => gasLimit;\n\n    // Create a function that executes the tx when called\n    const execute = async (nonce: number, gasLimit: BigNumberish) => {\n      try {\n        const member = target.populateTransaction[prop as string];\n        if (member == undefined) {\n          throw new Error(\"Member does not exist.\");\n        }\n\n        if (!(member instanceof Function)) {\n          throw new Error(\n            `Internal TxQueue error: Member is not a function and should not be proxied. Tried to call \"${String(\n              prop\n            )}\".`\n          );\n        }\n\n        // Populate config\n        const configOverrides = {\n          gasPrice: gasPrice$.getValue(),\n          ...overrides,\n          nonce,\n          gasLimit,\n        };\n        if (options?.devMode) configOverrides.gasPrice = 0;\n\n        // Populate tx\n        const populatedTx = await member(...argsWithoutOverrides, configOverrides);\n        populatedTx.nonce = nonce;\n        populatedTx.chainId = network.config.chainId;\n\n        // Execute tx\n        let hash: string;\n        try {\n          // Attempt to sign the transaction and send it raw for higher performance\n          const signedTx = await target.signer.signTransaction(populatedTx);\n          hash = await (target.provider as JsonRpcProvider).perform(\"sendTransaction\", {\n            signedTransaction: signedTx,\n          });\n        } catch (e) {\n          // Some signers don't support signing without sending (looking at you MetaMask),\n          // so sign+send using the signer as a fallback\n          const tx = await target.signer.sendTransaction(populatedTx);\n          hash = tx.hash;\n        }\n        const response = target.provider.getTransaction(hash) as Promise<\n          ReturnTypeStrict<(typeof target)[typeof prop]>\n        >;\n        // This promise is awaited asynchronously in the tx queue and the action queue to catch errors\n        const wait = async () => (await response).wait();\n\n        // Resolved value goes to the initiator of the transaction\n        resolve({ hash, wait, response });\n\n        // Returned value gets processed inside the tx queue\n        return { hash, wait };\n      } catch (e) {\n        reject(e as Error);\n        throw e; // Rethrow error to catch when processing the queue\n      }\n    };\n\n    // Queue the tx execution\n    queue.add(uuid(), {\n      execute,\n      estimateGas,\n      cancel: (error?: any) => reject(error ?? new Error(\"TX_CANCELLED\")),\n      stateMutability,\n    });\n\n    // Start processing the queue\n    processQueue();\n\n    // Promise resolves when the transaction is confirmed and is rejected if the\n    // transaction fails or is cancelled.\n    return promise;\n  }\n\n  async function processQueue() {\n    // Don't enter if at max capacity\n    if (concurrency != null && utilization >= concurrency) return;\n\n    // Check if there is a request to process\n    const txRequest = queue.next();\n    if (!txRequest) return;\n\n    // Increase utilization to prevent executing more tx than allowed by capacity\n    utilization++;\n\n    // Start processing another request from the queue\n    // Note: we start processing again after increasing the utilization to process up to `concurrency` tx request in parallel.\n    // At the end of this function after decreasing the utilization we call processQueue again trigger tx requests waiting for capacity.\n    processQueue();\n\n    // Run exclusive to avoid two tx requests awaiting the nonce in parallel and submitting with the same nonce.\n    const txResult = await submissionMutex.runExclusive(async () => {\n      // Define variables in scope visible to finally block\n      let error: any;\n      const stateMutability = txRequest.stateMutability;\n\n      // Await gas estimation to avoid increasing nonce before tx is actually sent\n      let gasLimit: BigNumberish;\n      try {\n        gasLimit = await txRequest.estimateGas();\n      } catch (e) {\n        console.error(\"[TXQueue] GAS ESTIMATION ERROR\", e);\n        return txRequest.cancel(e);\n      }\n\n      // Wait if nonce is not ready\n      const { nonce } = await awaitValue(readyState);\n\n      try {\n        return await txRequest.execute(nonce, gasLimit);\n      } catch (e: any) {\n        console.warn(\"[TXQueue] TXQUEUE EXECUTION FAILED\", e);\n        // Nonce is handled centrally in finally block (for both failing and successful tx)\n        error = e;\n      } finally {\n        // If the error includes information about the transaction,\n        // then the transaction was submitted and the nonce needs to be\n        // increased regardless of the error\n        const isNonViewTransaction =\n          error &&\n          \"transaction\" in error &&\n          !(\"insufficient funds\" in error) &&\n          !(\"mispriced\" in error) &&\n          txRequest.stateMutability !== \"view\";\n        const shouldIncreaseNonce = (!error && stateMutability !== \"view\") || isNonViewTransaction;\n\n        const shouldResetNonce =\n          error &&\n          ((\"code\" in error && error.code === \"NONCE_EXPIRED\") ||\n            JSON.stringify(error).includes(\"transaction already imported\"));\n        console.log(\n          `[TXQueue] TX Sent (error=${!!error}, isMutationError=${!!isNonViewTransaction} incNonce=${!!shouldIncreaseNonce} resetNonce=${!!shouldResetNonce})`\n        );\n        // Nonce handeling\n        if (shouldIncreaseNonce) incNonce();\n        if (shouldResetNonce) await resetNonce();\n        // Bubble up error\n        if (error) txRequest.cancel(error);\n      }\n    });\n\n    // Await confirmation\n    if (txResult?.hash) {\n      try {\n        await txResult.wait();\n      } catch (e) {\n        console.warn(\"[TXQueue] tx failed in block\", e);\n\n        // Decode and log the revert reason.\n        // Use `then` instead of `await` to avoid letting consumers wait.\n        getRevertReason(txResult.hash, network.providers.get().json)\n          .then((reason) => console.warn(\"[TXQueue] Revert reason:\", reason))\n          .catch((_) => \"This transaction didn't make it into a block. Was it mispriced?\");\n\n        const params = new URLSearchParams(window.location.search);\n        const worldAddress = params.get(\"worldAddress\");\n        // Log useful commands that can be used to replay this tx\n        const trace = `mud trace --config deploy.json --world ${worldAddress} --tx ${txResult.hash}`;\n\n        console.log(\"---------- DEBUG COMMANDS (RUN IN TERMINAL) -------------\");\n        console.log(\"Trace:\");\n        console.log(trace);\n        console.log(\"---------------------------------------------------------\");\n      }\n    }\n\n    utilization--;\n\n    // Check if there are any transactions waiting to be processed\n    processQueue();\n  }\n\n  function proxyContract<Contract extends C[keyof C]>(contract: Contract): Contract {\n    return mapObject(contract as any, (value, key) => {\n      // Relay all base contract methods to the original target\n      if (key in BaseContract.prototype) return value;\n\n      // Relay everything that is not a function call to the original target\n      if (!(value instanceof Function)) return value;\n\n      // Channel all contract specific methods through the queue\n      return (...args: unknown[]) => queueCall(contract, key as keyof BaseContract, args);\n    }) as Contract;\n  }\n\n  const proxiedContracts = computed(() => {\n    const contracts = readyState.get()?.contracts;\n    if (!contracts) return undefined;\n    return mapObject(contracts, proxyContract);\n  });\n\n  const cachedProxiedContracts = cacheUntilReady(proxiedContracts);\n\n  return { txQueue: cachedProxiedContracts, dispose, ready: computed(() => (readyState ? true : undefined)) };\n}\n\nfunction isOverrides(obj: any): obj is Overrides {\n  if (typeof obj !== \"object\" || Array.isArray(obj) || obj === null) return false;\n  return (\n    \"gasLimit\" in obj ||\n    \"gasPrice\" in obj ||\n    \"maxFeePerGas\" in obj ||\n    \"maxPriorityFeePerGas\" in obj ||\n    \"nonce\" in obj ||\n    \"type\" in obj ||\n    \"accessList\" in obj ||\n    \"customData\" in obj ||\n    \"value\" in obj ||\n    \"blockTag\" in obj ||\n    \"from\" in obj\n  );\n}\n\n/**\n * Simple priority queue\n * @returns priority queue object\n */\nfunction createPriorityQueue<T>() {\n  const queue = new Map<string, { element: T; priority: number }>();\n\n  function queueByPriority() {\n    // Entries with a higher priority get executed first\n    return [...queue.entries()].sort((a, b) => (a[1].priority >= b[1].priority ? -1 : 1));\n  }\n\n  function add(id: string, element: T, priority = 1) {\n    queue.set(id, { element, priority });\n  }\n\n  function remove(id: string) {\n    queue.delete(id);\n  }\n\n  function setPriority(id: string, priority: number) {\n    const entry = queue.get(id);\n    if (!entry) return;\n    queue.set(id, { ...entry, priority });\n  }\n\n  function next(): T | undefined {\n    if (queue.size === 0) return;\n    const [key, value] = queueByPriority()[0];\n    queue.delete(key);\n    return value.element;\n  }\n\n  function size(): number {\n    return queue.size;\n  }\n\n  return { add, remove, setPriority, next, size };\n}\n","import { Components } from \"@latticexyz/recs\";\nimport { fromWorker } from \"@latticexyz/utils\";\nimport { map, Observable, Subject, timer } from \"rxjs\";\nimport { NetworkEvent } from \"./types\";\nimport { Input, Ack, ack, SyncWorker } from \"./workers/SyncWorker\";\n\n/**\n * Create a new SyncWorker ({@link Sync.worker.ts}) to performn contract/client state sync.\n * The main thread and worker communicate via RxJS streams.\n *\n * @returns Object {\n * ecsEvent$: Stream of network component updates synced by the SyncWorker,\n * config$: RxJS subject to pass in config for the SyncWorker,\n * dispose: function to dispose of the sync worker\n * }\n */\nexport function createSyncWorker<C extends Components = Components>(\n  ack$?: Observable<Ack>,\n  options?: { thread?: \"main\" | \"worker\" }\n) {\n  const thread = options?.thread || \"worker\";\n  const input$ = new Subject<Input>();\n  const ecsEvents$ = new Subject<NetworkEvent<C>[]>();\n  // let dispose: () => void;\n\n  // Send ack every 16ms if no external ack$ is provided\n  ack$ = ack$ || timer(0, 16).pipe(map(() => ack));\n  const ackSub = ack$.subscribe(input$);\n\n  // If thread option is \"worker\", create a new web worker to sync the state\n  // if (thread === \"worker\") {\n  //   const worker = new Worker(new URL(\"./workers/Sync.worker.js\", import.meta.url), { type: \"module\" });\n\n  //   // Pass in a \"config stream\", receive a stream of ECS events\n  //   const subscription = fromWorker<Input, NetworkEvent<C>[]>(worker, input$).subscribe(ecsEvents$);\n  //   dispose = () => {\n  //     worker.terminate();\n  //     subscription?.unsubscribe();\n  //     ackSub?.unsubscribe();\n  //   };\n  // } else {\n  // Otherwise sync the state in the main thread\n  // Pass in a \"config stream\", receive a stream of ECS events\n  const subscription = new SyncWorker<C>().work(input$).subscribe(ecsEvents$);\n  const dispose = () => {\n    subscription?.unsubscribe();\n    ackSub?.unsubscribe();\n  };\n  // }\n\n  return {\n    ecsEvents$,\n    input$,\n    dispose,\n  };\n}\n","import { ethers, VoidSigner } from \"ethers\";\nimport { ContractTopics } from \"./types\";\nimport { Contracts } from \"./types\";\n\nexport type TopicsConfig<C extends Contracts> = {\n  [ContractType in keyof C]: {\n    abi: ethers.ContractInterface;\n    topics: (keyof C[ContractType][\"filters\"])[];\n  };\n};\n\nexport function createTopics<C extends Contracts>(config: TopicsConfig<C>): ContractTopics[] {\n  const contractTopics: ContractTopics[] = [];\n  for (const key of Object.keys(config)) {\n    const { abi, topics } = config[key];\n    const dummyContract = new ethers.Contract(\n      ethers.constants.AddressZero,\n      abi,\n      new VoidSigner(ethers.constants.AddressZero)\n    ) as C[typeof key];\n    const contractTopic = [\n      topics\n        .map((t) => dummyContract.filters[t as string]().topics)\n        .map((topicsOrUndefined) => (topicsOrUndefined || [])[0]),\n    ] as Array<Array<string>>;\n    contractTopics.push({\n      key,\n      topics: contractTopic,\n    });\n  }\n  return contractTopics;\n}\n","import { BigNumber } from \"ethers\";\nimport { BytesLike, defaultAbiCoder as abi } from \"ethers/lib/utils.js\";\nimport {\n  ContractSchemaValue,\n  ContractSchemaValueArrayToElement,\n  ContractSchemaValueId,\n  ContractSchemaValueTypes,\n} from \"./types\";\n\nexport function flattenValue<V extends ContractSchemaValue>(\n  value: BigNumber | BigNumber[] | number | number[] | boolean | boolean[] | string | string[],\n  valueType: V\n): ContractSchemaValueTypes[V] {\n  // If value is array, recursively flatten elements\n  if (Array.isArray(value))\n    return value.map((v) =>\n      flattenValue(v, ContractSchemaValueArrayToElement[valueType])\n    ) as unknown as ContractSchemaValueTypes[V]; // Typescript things it is possible we return a nested array, but it is not\n\n  // Value is already flat\n  if (typeof value === \"number\" || typeof value === \"string\" || typeof value === \"boolean\")\n    return value as ContractSchemaValueTypes[V];\n\n  // The value returned by abi.decode is Hexable but not a ethers.BigNumber\n  value = BigNumber.from(value);\n\n  // Value is a representable number\n  if (\n    [\n      ContractSchemaValue.INT8,\n      ContractSchemaValue.INT16,\n      ContractSchemaValue.INT32,\n      ContractSchemaValue.UINT8,\n      ContractSchemaValue.UINT16,\n      ContractSchemaValue.UINT32,\n    ].includes(valueType)\n  ) {\n    return value.toNumber() as ContractSchemaValueTypes[V];\n  }\n\n  // Value should be represented as a hex string\n  if (\n    [\n      ContractSchemaValue.INT64,\n      ContractSchemaValue.INT128,\n      ContractSchemaValue.INT256,\n      ContractSchemaValue.UINT64,\n      ContractSchemaValue.UINT128,\n      ContractSchemaValue.UINT256,\n      ContractSchemaValue.BYTES,\n      ContractSchemaValue.ADDRESS,\n      ContractSchemaValue.BYTES4,\n    ].includes(valueType)\n  ) {\n    return value.toHexString() as ContractSchemaValueTypes[V];\n  }\n\n  // Value should be represented a plain string\n  if ([ContractSchemaValue.STRING].includes(valueType)) {\n    return value.toString() as ContractSchemaValueTypes[V];\n  }\n\n  throw new Error(\"Unknown value type\");\n}\n\n/**\n * Construct a decoder function from given keys and valueTypes.\n * The consumer is responsible for providing a type D matching the keys and valueTypes.\n *\n * @param keys Keys of the component value schema.\n * @param valueTypes Value types if the component value schema.\n * @returns Function to decode encoded hex value to component value.\n */\nexport function createDecoder<D extends { [key: string]: unknown }>(\n  keys: (keyof D)[],\n  valueTypes: ContractSchemaValue[]\n): (data: BytesLike) => D {\n  return (data: BytesLike) => {\n    // Decode data with the schema values provided by the component\n    const decoded = abi.decode(\n      valueTypes.map((valueType) => ContractSchemaValueId[valueType]),\n      data\n    );\n\n    // Now keys and valueTypes lengths must match\n    if (keys.length !== valueTypes.length) {\n      throw new Error(\"Component schema keys and values length does not match\");\n    }\n\n    // Construct the client component value\n    const result: Partial<{ [key in keyof D]: unknown }> = {};\n    for (let i = 0; i < keys.length; i++) {\n      result[keys[i]] = flattenValue(decoded[i], valueTypes[i]);\n    }\n\n    return result as D;\n  };\n}\n","import { ContractSchemaValue, ContractSchemaValueId } from \"./types\";\nimport { defaultAbiCoder as abi } from \"ethers/lib/utils.js\";\n\n/**\n * Creates a function to automatically encode component values given a contract component schema.\n *\n * @param keys Schema keys\n * @param valueTypes Schema value types\n * @returns Function to encode component values\n */\nexport function createEncoder<D extends { [key: string]: unknown }>(\n  keys: (keyof D)[],\n  valueTypes: ContractSchemaValue[]\n): (value: D) => string {\n  return (value) => {\n    const contractArgTypes = [] as string[];\n    const contractArgs = Object.values(value);\n\n    for (const componentValueProp of Object.keys(value)) {\n      const index = keys.findIndex((key) => key === componentValueProp);\n      contractArgTypes.push(ContractSchemaValueId[valueTypes[index] as ContractSchemaValue]);\n    }\n\n    return abi.encode(contractArgTypes, contractArgs);\n  };\n}\n","import { Provider } from \"@ethersproject/providers\";\nimport { Component, Entity, getComponentEntities, getComponentValue, Type, World } from \"@latticexyz/recs\";\nimport { deferred, keccak256, toEthAddress } from \"@latticexyz/utils\";\nimport { Contract, ContractInterface, Signer } from \"ethers\";\nimport { observable, runInAction } from \"mobx\";\nimport { createTxQueue } from \"./createTxQueue\";\nimport { Network } from \"./createNetwork\";\nimport { BehaviorSubject } from \"rxjs\";\n\n/**\n * Create a system executor object.\n * The system executor object is an object indexed by available system ids (given in the interfaces object)\n * with {@link createTxQueue tx-queue enabled system contracts} as value.\n *\n * @param world Recs World object.\n * @param network Network ({@link createNetwork}).\n * @param systems Recs registry component containing the mapping from system address to system id.\n * @param interfaces Interfaces of the systems to create.\n * @param options\n * @returns Systems object to call system contracts.\n */\nexport function createSystemExecutor<T extends { [key: string]: Contract }>(\n  world: World,\n  network: Network,\n  systems: Component<{ value: Type.String }>,\n  interfaces: { [key in keyof T]: ContractInterface },\n  gasPrice$: BehaviorSubject<number>,\n  options?: { devMode?: boolean; concurrency?: number }\n) {\n  const systemContracts = observable.box({} as T);\n  const systemIdPreimages: { [key: string]: string } = Object.keys(interfaces).reduce((acc, curr) => {\n    return { ...acc, [keccak256(curr)]: curr };\n  }, {});\n\n  // Util to add new systems to the systems tx queue\n  function registerSystem(system: { id: string; contract: Contract }) {\n    const [resolve, , promise] = deferred<void>();\n    runInAction(() => {\n      systemContracts.set({ ...systemContracts.get(), [system.id]: system.contract });\n      systemIdPreimages[keccak256(system.id)] = system.id;\n      resolve();\n    });\n\n    return promise;\n  }\n\n  // Initialize systems\n  const initialContracts = {} as T;\n  for (const systemEntity of getComponentEntities(systems)) {\n    const system = createSystemContract(systemEntity, network.signer.get());\n    if (!system) continue;\n    initialContracts[system.id as keyof T] = system.contract as T[keyof T];\n  }\n  runInAction(() => systemContracts.set(initialContracts));\n\n  // Keep up to date\n  systems.update$.subscribe((update) => {\n    if (!update.value[0]) return;\n    const system = createSystemContract(update.entity, network.signer.get());\n    if (!system) return;\n    registerSystem(system);\n  });\n\n  const { txQueue, dispose } = createTxQueue<T>(systemContracts, network, gasPrice$, options);\n  world.registerDisposer(dispose);\n\n  return { systems: txQueue, registerSystem, getSystemContract };\n\n  function getSystemContract(systemId: string) {\n    const name = systemIdPreimages[systemId];\n\n    return {\n      name,\n      contract: systemContracts.get()[name],\n    };\n  }\n\n  function createSystemContract<C extends Contract>(\n    entity: Entity,\n    signerOrProvider?: Signer | Provider\n  ): { id: string; contract: C } | undefined {\n    const { value: hashedSystemId } = getComponentValue(systems, entity) || {};\n    if (!hashedSystemId) throw new Error(\"System entity not found\");\n    const id = systemIdPreimages[hashedSystemId];\n    if (!id) {\n      console.warn(\"Unknown system:\", hashedSystemId);\n      return;\n    }\n    return {\n      id,\n      contract: new Contract(toEthAddress(entity), interfaces[id], signerOrProvider) as C,\n    };\n  }\n}\n","import { Signer } from \"ethers\";\nimport { from, map, Subject } from \"rxjs\";\nimport { spawn } from \"threads\";\nimport { messagePayload } from \"./utils\";\nimport { createChannel, createClient } from \"nice-grpc-web\";\nimport { awaitPromise, awaitStreamValue } from \"@latticexyz/utils\";\nimport { grpc } from \"@improbable-eng/grpc-web\";\nimport { ECSRelayServiceDefinition, Message, PushRequest } from \"@latticexyz/services/ecs-relay\";\nimport { recoverAddress } from \"./workers/Recover.worker\";\n// import RecoverWorker from './workers/Recover.worker.js';\n\n/**\n * Create a RelayService connection, including event$ and utils\n * @param url ECSRelayService URL\n * @param id User id (eg address)\n * @returns RelayService connection\n */\nexport async function createRelayStream(signer: Signer, url: string, id: string) {\n  const httpClient = createClient(ECSRelayServiceDefinition, createChannel(url));\n  const wsClient = createClient(ECSRelayServiceDefinition, createChannel(url, grpc.WebsocketTransport()));\n\n  // const recoverWorker = await spawn(\n  //   new Worker(new URL(\"./workers/Recover.worker.js\", import.meta.url), { type: \"module\" })\n  // );\n\n  // Signature that should be used to prove identity\n  const signature = { signature: await signer.signMessage(\"ecs-relay-service\") };\n  await httpClient.authenticate(signature);\n\n  // Subscribe to the stream of relayed events\n  const event$ = from(wsClient.openStream(signature)).pipe(\n    map(async (message) => ({\n      message,\n      address: await recoverAddress(message),\n    }))\n    // awaitPromise()\n  );\n\n  // Subscribe to new labels\n  function subscribe(label: string) {\n    httpClient.subscribe({ signature, subscription: { label } });\n  }\n\n  // Unsubscribe from labels\n  function unsubscribe(label: string) {\n    httpClient.unsubscribe({ signature, subscription: { label } });\n  }\n\n  // Fetch amount of connected clients\n  async function countConnected(): Promise<number> {\n    const { count } = await httpClient.countConnected({});\n    return count;\n  }\n\n  // Set up stream to push messages to the relay service\n  const push$ = new Subject<PushRequest>();\n  const generatorLoop = { done: false };\n\n  async function* pushGenerator(): AsyncIterable<PushRequest> {\n    while (!generatorLoop.done) {\n      yield await awaitStreamValue(push$);\n    }\n  }\n\n  // Open push stream\n  const responseSubscription = from(wsClient.pushStream(pushGenerator())).subscribe();\n\n  function dispose() {\n    generatorLoop.done = true;\n    responseSubscription?.unsubscribe();\n  }\n\n  // Expose method for consumers to push data through the stream\n  async function push(label: string, data: Uint8Array) {\n    const message: Message = { version: 1, id: Date.now() + id, timestamp: Date.now(), data, signature: \"\" };\n    message.signature = await signer.signMessage(messagePayload(message));\n    push$.next({ label, message });\n  }\n\n  // Expose method for consumers to ping the stream to keep receiving messages without pushing\n  function ping() {\n    return httpClient.ping(signature);\n  }\n\n  return { event$, dispose, subscribe, unsubscribe, push, countConnected, ping };\n}\n","import { FaucetServiceDefinition } from \"@latticexyz/services/faucet\";\nimport { createChannel, createClient, RawClient } from \"nice-grpc-web\";\nimport { FromTsProtoServiceDefinition } from \"nice-grpc-web/lib/service-definitions/ts-proto\";\n\n/**\n * Create a FaucetServiceClient\n * @param url FaucetService URL\n * @returns FaucetServiceClient\n */\nexport function createFaucetService(\n  url: string\n): RawClient<FromTsProtoServiceDefinition<typeof FaucetServiceDefinition>> {\n  return createClient(FaucetServiceDefinition, createChannel(url));\n}\n","import { BigNumber, Contract, Overrides, Signer } from \"ethers\";\nimport { JsonRpcProvider } from \"@ethersproject/providers\";\nimport * as devObservables from \"./dev/observables\";\n\n/**\n * Create a stateful util to execute transactions as fast as possible.\n * Internal state includes the current nonce and the current gas price.\n *\n * Note: since the signer's nonce is managed in the internal state of this\n * function, using the same signer to send transactions outside of this function\n * or creating multiple instances of this function with the same signer will result\n * in nonce errors.\n */\nexport async function createFastTxExecutor(\n  signer: Signer & { provider: JsonRpcProvider },\n  globalOptions: { priorityFeeMultiplier: number } = { priorityFeeMultiplier: 1 }\n) {\n  const chainId = await signer.getChainId();\n\n  const currentNonce = {\n    nonce: await signer.getTransactionCount(),\n  };\n\n  // This gas config is updated\n  const gasConfig: {\n    maxPriorityFeePerGas?: number;\n    maxFeePerGas?: BigNumber;\n  } = {};\n  await updateFeePerGas(globalOptions.priorityFeeMultiplier);\n\n  /**\n   * Execute a transaction as fast as possible by skipping a couple unnecessary RPC calls ethers does.\n   */\n  async function fastTxExecute<C extends Contract, F extends keyof C>(\n    contract: C,\n    func: F,\n    args: Parameters<C[F]>,\n    options: {\n      retryCount?: number;\n    } = { retryCount: 0 }\n  ): Promise<{ hash: string; tx: ReturnType<C[F]> }> {\n    const functionName = `${func as string}(${args.map((arg) => `'${arg}'`).join(\",\")})`;\n    console.log(`executing transaction: ${functionName} with nonce ${currentNonce.nonce}`);\n\n    try {\n      // Separate potential overrides from the args to extend the overrides below\n      const { argsWithoutOverrides, overrides } = separateOverridesFromArgs(args);\n\n      // Estimate gas if no gas limit was provided\n      const gasLimit = overrides.gasLimit ?? (await contract.estimateGas[func as string].apply(null, args));\n\n      // Apply default overrides\n      const fullOverrides = { type: 2, gasLimit, nonce: currentNonce.nonce++, ...gasConfig, ...overrides };\n\n      // Populate the transaction\n      const populatedTx = await contract.populateTransaction[func as string](...argsWithoutOverrides, fullOverrides);\n      populatedTx.chainId = chainId;\n\n      // Execute the transaction\n      let hash: string;\n      try {\n        // Attempt to sign the transaction and send it raw for higher performance\n        const signedTx = await signer.signTransaction(populatedTx);\n        hash = await signer.provider.perform(\"sendTransaction\", {\n          signedTransaction: signedTx,\n        });\n      } catch (e) {\n        // Some signers don't support signing without sending (looking at you MetaMask),\n        // so sign+send using the signer as a fallback\n        console.warn(\"signing failed, falling back to sendTransaction\", e);\n        const tx = await signer.sendTransaction(populatedTx);\n        hash = tx.hash;\n      }\n\n      // TODO: emit txs that fail gas estimation so we can display em in dev tools\n      devObservables.transactionHash$.next(hash);\n\n      // Return the transaction promise and transaction hash.\n      // The hash is available immediately, the full transaction is available as a promise\n      const tx = signer.provider.getTransaction(hash) as ReturnType<C[F]>;\n\n      return { hash, tx };\n    } catch (error: any) {\n      // Handle \"transaction already imported\" errors\n      if (error?.message.includes(\"transaction already imported\")) {\n        if (options.retryCount === 0) {\n          updateFeePerGas(globalOptions.priorityFeeMultiplier * 1.1);\n          return fastTxExecute(contract, func, args, { retryCount: options.retryCount++ });\n        } else {\n          throw new Error(`Gas estimation error for ${functionName}: ${error?.reason}`);\n        }\n      }\n\n      // TODO: potentially handle more transaction errors here, like:\n      // \"insufficient funds for gas * price + value\" -> request funds from faucet\n      // \"invalid nonce\" -> update nonce\n\n      // Rethrow all other errors\n      throw error;\n    }\n  }\n\n  /**\n   * Set the maxFeePerGas and maxPriorityFeePerGas based on the current base fee and the given multiplier.\n   * The multiplier is used to allow replacing pending transactions.\n   * @param multiplier Multiplier to apply to the base fee\n   */\n  async function updateFeePerGas(multiplier: number) {\n    // Compute maxFeePerGas and maxPriorityFeePerGas like ethers, but allow for a multiplier to allow replacing pending transactions\n    const feeData = await signer.provider.getFeeData();\n    if (!feeData.lastBaseFeePerGas) throw new Error(\"Can not fetch lastBaseFeePerGas from RPC\");\n\n    // Set the priority fee to 0 for development chains with no base fee, to allow transactions from unfunded wallets\n    gasConfig.maxPriorityFeePerGas = feeData.lastBaseFeePerGas.eq(0) ? 0 : Math.floor(1_500_000_000 * multiplier);\n    gasConfig.maxFeePerGas = feeData.lastBaseFeePerGas.mul(2).add(gasConfig.maxPriorityFeePerGas);\n  }\n\n  return {\n    fastTxExecute,\n    updateFeePerGas,\n    gasConfig: gasConfig as Readonly<typeof gasConfig>,\n    currentNonce: currentNonce as Readonly<typeof currentNonce>,\n  };\n}\n\nfunction separateOverridesFromArgs<T>(args: Array<T>) {\n  // Extract existing overrides from function call\n  const hasOverrides = args.length > 0 && isOverrides(args[args.length - 1]);\n  const overrides = (hasOverrides ? args[args.length - 1] : {}) as Overrides;\n  const argsWithoutOverrides = hasOverrides ? args.slice(0, args.length - 1) : args;\n\n  return { argsWithoutOverrides, overrides };\n}\n\nfunction isOverrides(obj: any): obj is Overrides {\n  if (typeof obj !== \"object\" || Array.isArray(obj) || obj === null) return false;\n  return (\n    \"gasLimit\" in obj ||\n    \"gasPrice\" in obj ||\n    \"maxFeePerGas\" in obj ||\n    \"maxPriorityFeePerGas\" in obj ||\n    \"nonce\" in obj ||\n    \"type\" in obj ||\n    \"accessList\" in obj ||\n    \"customData\" in obj ||\n    \"value\" in obj ||\n    \"blockTag\" in obj ||\n    \"from\" in obj\n  );\n}\n","import { TableId } from \"@latticexyz/common\";\nimport { Hex } from \"viem\";\nimport snapSyncSystemAbi from \"./snapSyncSystemAbi\";\nimport { Contract, Signer, providers } from \"ethers\";\nimport { RawTableRecord } from \"../../types\";\n\nexport async function getSnapSyncRecords(\n  worldAddress: string,\n  tables: TableId[],\n  currentBlockNumber: number,\n  signerOrProvider: Signer | providers.JsonRpcProvider\n) {\n  const snapSyncContract = new Contract(worldAddress, snapSyncSystemAbi, signerOrProvider);\n\n  const chunkSize = 100;\n  const tableIds = tables.map((table) => table.toHex());\n  const tableRecords = [] as RawTableRecord[];\n  for (const tableId of tableIds) {\n    const numKeys = (\n      await snapSyncContract.callStatic[\"snapSync_system_getNumKeysInTable\"](tableId, {\n        blockTag: currentBlockNumber,\n      })\n    ).toNumber();\n    if (numKeys === 0) continue;\n\n    let remainingKeys = numKeys;\n    const numChunks = Math.ceil(numKeys / chunkSize);\n    for (let i = 0; i < numChunks; i++) {\n      const limit = Math.min(remainingKeys, chunkSize);\n      const offset = i * chunkSize;\n      remainingKeys -= limit;\n\n      const records = await snapSyncContract.callStatic[\"snapSync_system_getRecords\"](tableId, limit, offset, {\n        blockTag: currentBlockNumber,\n      });\n      const transformedRecords = records.map((record: [string, string[], string]) => {\n        return {\n          tableId: TableId.fromHex(record[0] as Hex),\n          keyTuple: record[1],\n          value: record[2],\n        };\n      });\n      tableRecords.push(...transformedRecords);\n    }\n  }\n\n  return tableRecords;\n}\n","// TODO: autogenerate this and import from the SnapSync module\n// (see https://github.com/latticexyz/mud/issues/836)\nexport default [\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"tableId\",\n        type: \"bytes32\",\n      },\n    ],\n    name: \"snapSync_system_getNumKeysInTable\",\n    outputs: [\n      {\n        internalType: \"uint256\",\n        name: \"\",\n        type: \"uint256\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n  {\n    inputs: [\n      {\n        internalType: \"bytes32\",\n        name: \"tableId\",\n        type: \"bytes32\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"limit\",\n        type: \"uint256\",\n      },\n      {\n        internalType: \"uint256\",\n        name: \"offset\",\n        type: \"uint256\",\n      },\n    ],\n    name: \"snapSync_system_getRecords\",\n    outputs: [\n      {\n        components: [\n          {\n            internalType: \"bytes32\",\n            name: \"tableId\",\n            type: \"bytes32\",\n          },\n          {\n            internalType: \"bytes32[]\",\n            name: \"keyTuple\",\n            type: \"bytes32[]\",\n          },\n          {\n            internalType: \"bytes\",\n            name: \"value\",\n            type: \"bytes\",\n          },\n        ],\n        internalType: \"struct SyncRecord[]\",\n        name: \"\",\n        type: \"tuple[]\",\n      },\n    ],\n    stateMutability: \"view\",\n    type: \"function\",\n  },\n];\n"],"mappings":"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","names":["computed","observable","toJS","Wallet","createSigner","privateKey","providers","combineLatest","concatMap","EMPTY","filter","map","throttleTime","ReplaySubject","createClock","config","initialTime","period","clock","intervalId","update","createTickInterval","emit","time","Wallet","computedToStream","privateKeyToAccount","fallback","webSocket","http","createPublicClient","createWalletClient","mudChains","chains","createNetwork","initialConfig","config","observable","disposers","providers","connected","disposeProvider","createReconnectingProvider","computed","toJS","signer","currentProviders","privateKey","createSigner","initialConnectedAddress","connectedAddress","Wallet","connectedAddressChecksummed","blockNumber$","disposeBlockNumberStream","createBlockNumberStream","clock","createClock","syncBlockSub","combineLatest","computedToStream","throttleTime","concatMap","blockNumber","fetchBlock","EMPTY","map","block","filter","blockTimestamp","possibleChains","mudChains","chains","chain","c","publicClient","createPublicClient","fallback","webSocket","http","burnerAccount","privateKeyToAccount","burnerWalletClient","createWalletClient","publicClient$","walletClient$","error","disposer","Contract","computed","mapObject","createContracts","config","asyncConfig","signerOrProvider","contracts","asyncConfigResult","asyncContracts","BaseContract","autorun","computed","observable","runInAction","mapObject","deferred","uuid","awaitValue","cacheUntilReady","Mutex","createTxQueue","computedContracts","network","gasPrice$","options","concurrency","queue","createPriorityQueue","submissionMutex","Mutex","_nonce","observable","readyState","computed","connected","contracts","signer","provider","nonce","utilization","resetNonce","runInAction","newNonce","dispose","autorun","incNonce","currentNonce","queueCall","target","prop","args","resolve","reject","promise","deferred","hasOverrides","isOverrides","overrides","argsWithoutOverrides","fragment","stateMutability","gasLimit","estimateGas","execute","member","configOverrides","populatedTx","hash","signedTx","response","wait","e","uuid","error","processQueue","txRequest","txResult","awaitValue","isNonViewTransaction","shouldIncreaseNonce","shouldResetNonce","getRevertReason","reason","_","trace","proxyContract","contract","mapObject","value","key","BaseContract","proxiedContracts","cacheUntilReady","obj","queueByPriority","a","b","add","id","element","priority","remove","setPriority","entry","next","size","map","Subject","timer","createSyncWorker","ack$","options","thread","input$","Subject","ecsEvents$","timer","map","ack","ackSub","subscription","SyncWorker","ethers","VoidSigner","createTopics","config","contractTopics","key","abi","topics","dummyContract","contractTopic","t","topicsOrUndefined","BigNumber","abi","flattenValue","value","valueType","v","ContractSchemaValueArrayToElement","BigNumber","createDecoder","keys","valueTypes","data","decoded","abi","ContractSchemaValueId","result","abi","createEncoder","keys","valueTypes","value","contractArgTypes","contractArgs","componentValueProp","index","key","ContractSchemaValueId","getComponentEntities","getComponentValue","deferred","keccak256","toEthAddress","Contract","observable","runInAction","createSystemExecutor","world","network","systems","interfaces","gasPrice$","options","systemContracts","observable","systemIdPreimages","acc","curr","keccak256","registerSystem","system","resolve","promise","deferred","runInAction","initialContracts","systemEntity","getComponentEntities","createSystemContract","update","txQueue","dispose","createTxQueue","getSystemContract","systemId","name","entity","signerOrProvider","hashedSystemId","getComponentValue","id","Contract","toEthAddress","from","map","Subject","createChannel","createClient","awaitStreamValue","grpc","ECSRelayServiceDefinition","createRelayStream","signer","url","id","httpClient","createClient","ECSRelayServiceDefinition","createChannel","wsClient","grpc","signature","event$","from","map","message","recoverAddress","subscribe","label","unsubscribe","countConnected","count","push$","Subject","generatorLoop","pushGenerator","awaitStreamValue","responseSubscription","dispose","push","data","messagePayload","ping","FaucetServiceDefinition","createChannel","createClient","createFaucetService","url","createFastTxExecutor","signer","globalOptions","chainId","currentNonce","gasConfig","updateFeePerGas","fastTxExecute","contract","func","args","options","functionName","arg","argsWithoutOverrides","overrides","separateOverridesFromArgs","fullOverrides","populatedTx","hash","signedTx","e","transactionHash$","tx","error","multiplier","feeData","hasOverrides","isOverrides","obj","TableId","snapSyncSystemAbi_default","Contract","getSnapSyncRecords","worldAddress","tables","currentBlockNumber","signerOrProvider","snapSyncContract","snapSyncSystemAbi_default","chunkSize","tableIds","table","tableRecords","tableId","numKeys","remainingKeys","numChunks","i","limit","offset","transformedRecords","record","TableId"]}