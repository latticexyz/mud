/* eslint-disable */
// @generated by protobuf-ts 2.8.0 with parameter eslint_disable
// @generated from protobuf file "ecs-relay.proto" (package "ecsrelay", syntax proto3)
// tslint:disable
import type { RpcTransport } from "@protobuf-ts/runtime-rpc";
import type { ServiceInfo } from "@protobuf-ts/runtime-rpc";
import { ECSRelayService } from "./ecs-relay";
import type { PushManyRequest } from "./ecs-relay";
import type { PushResponse } from "./ecs-relay";
import type { PushRequest } from "./ecs-relay";
import type { DuplexStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { Message } from "./ecs-relay";
import type { ServerStreamingCall } from "@protobuf-ts/runtime-rpc";
import type { Subscription } from "./ecs-relay";
import type { SubscriptionRequest } from "./ecs-relay";
import type { CountIdentitiesResponse } from "./ecs-relay";
import type { CountIdentitiesRequest } from "./ecs-relay";
import { stackIntercept } from "@protobuf-ts/runtime-rpc";
import type { Identity } from "./ecs-relay";
import type { Signature } from "./ecs-relay";
import type { UnaryCall } from "@protobuf-ts/runtime-rpc";
import type { RpcOptions } from "@protobuf-ts/runtime-rpc";
/**
 * The Relay Service definition.
 *
 * @generated from protobuf service ecsrelay.ECSRelayService
 */
export interface IECSRelayServiceClient {
  /**
   * @generated from protobuf rpc: Authenticate(ecsrelay.Signature) returns (ecsrelay.Identity);
   */
  authenticate(input: Signature, options?: RpcOptions): UnaryCall<Signature, Identity>;
  /**
   * @generated from protobuf rpc: Revoke(ecsrelay.Signature) returns (ecsrelay.Identity);
   */
  revoke(input: Signature, options?: RpcOptions): UnaryCall<Signature, Identity>;
  /**
   * @generated from protobuf rpc: Ping(ecsrelay.Signature) returns (ecsrelay.Identity);
   */
  ping(input: Signature, options?: RpcOptions): UnaryCall<Signature, Identity>;
  /**
   * @generated from protobuf rpc: CountAuthenticated(ecsrelay.CountIdentitiesRequest) returns (ecsrelay.CountIdentitiesResponse);
   */
  countAuthenticated(
    input: CountIdentitiesRequest,
    options?: RpcOptions
  ): UnaryCall<CountIdentitiesRequest, CountIdentitiesResponse>;
  /**
   * @generated from protobuf rpc: CountConnected(ecsrelay.CountIdentitiesRequest) returns (ecsrelay.CountIdentitiesResponse);
   */
  countConnected(
    input: CountIdentitiesRequest,
    options?: RpcOptions
  ): UnaryCall<CountIdentitiesRequest, CountIdentitiesResponse>;
  /**
   * @generated from protobuf rpc: Subscribe(ecsrelay.SubscriptionRequest) returns (ecsrelay.Subscription);
   */
  subscribe(input: SubscriptionRequest, options?: RpcOptions): UnaryCall<SubscriptionRequest, Subscription>;
  /**
   * @generated from protobuf rpc: Unsubscribe(ecsrelay.SubscriptionRequest) returns (ecsrelay.Subscription);
   */
  unsubscribe(input: SubscriptionRequest, options?: RpcOptions): UnaryCall<SubscriptionRequest, Subscription>;
  /**
   * @generated from protobuf rpc: OpenStream(ecsrelay.Signature) returns (stream ecsrelay.Message);
   */
  openStream(input: Signature, options?: RpcOptions): ServerStreamingCall<Signature, Message>;
  /**
   * Push a stream of messages to be relayed.
   *
   * @generated from protobuf rpc: PushStream(stream ecsrelay.PushRequest) returns (stream ecsrelay.PushResponse);
   */
  pushStream(options?: RpcOptions): DuplexStreamingCall<PushRequest, PushResponse>;
  /**
   * Push a single message to be relayed.
   *
   * @generated from protobuf rpc: Push(ecsrelay.PushRequest) returns (ecsrelay.PushResponse);
   */
  push(input: PushRequest, options?: RpcOptions): UnaryCall<PushRequest, PushResponse>;
  /**
   * Push a series of messages to be relayed.
   *
   * @generated from protobuf rpc: PushMany(ecsrelay.PushManyRequest) returns (ecsrelay.PushResponse);
   */
  pushMany(input: PushManyRequest, options?: RpcOptions): UnaryCall<PushManyRequest, PushResponse>;
}
/**
 * The Relay Service definition.
 *
 * @generated from protobuf service ecsrelay.ECSRelayService
 */
export class ECSRelayServiceClient implements IECSRelayServiceClient, ServiceInfo {
  typeName = ECSRelayService.typeName;
  methods = ECSRelayService.methods;
  options = ECSRelayService.options;
  constructor(private readonly _transport: RpcTransport) {}
  /**
   * @generated from protobuf rpc: Authenticate(ecsrelay.Signature) returns (ecsrelay.Identity);
   */
  authenticate(input: Signature, options?: RpcOptions): UnaryCall<Signature, Identity> {
    const method = this.methods[0],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<Signature, Identity>("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: Revoke(ecsrelay.Signature) returns (ecsrelay.Identity);
   */
  revoke(input: Signature, options?: RpcOptions): UnaryCall<Signature, Identity> {
    const method = this.methods[1],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<Signature, Identity>("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: Ping(ecsrelay.Signature) returns (ecsrelay.Identity);
   */
  ping(input: Signature, options?: RpcOptions): UnaryCall<Signature, Identity> {
    const method = this.methods[2],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<Signature, Identity>("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: CountAuthenticated(ecsrelay.CountIdentitiesRequest) returns (ecsrelay.CountIdentitiesResponse);
   */
  countAuthenticated(
    input: CountIdentitiesRequest,
    options?: RpcOptions
  ): UnaryCall<CountIdentitiesRequest, CountIdentitiesResponse> {
    const method = this.methods[3],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<CountIdentitiesRequest, CountIdentitiesResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input
    );
  }
  /**
   * @generated from protobuf rpc: CountConnected(ecsrelay.CountIdentitiesRequest) returns (ecsrelay.CountIdentitiesResponse);
   */
  countConnected(
    input: CountIdentitiesRequest,
    options?: RpcOptions
  ): UnaryCall<CountIdentitiesRequest, CountIdentitiesResponse> {
    const method = this.methods[4],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<CountIdentitiesRequest, CountIdentitiesResponse>(
      "unary",
      this._transport,
      method,
      opt,
      input
    );
  }
  /**
   * @generated from protobuf rpc: Subscribe(ecsrelay.SubscriptionRequest) returns (ecsrelay.Subscription);
   */
  subscribe(input: SubscriptionRequest, options?: RpcOptions): UnaryCall<SubscriptionRequest, Subscription> {
    const method = this.methods[5],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<SubscriptionRequest, Subscription>("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: Unsubscribe(ecsrelay.SubscriptionRequest) returns (ecsrelay.Subscription);
   */
  unsubscribe(input: SubscriptionRequest, options?: RpcOptions): UnaryCall<SubscriptionRequest, Subscription> {
    const method = this.methods[6],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<SubscriptionRequest, Subscription>("unary", this._transport, method, opt, input);
  }
  /**
   * @generated from protobuf rpc: OpenStream(ecsrelay.Signature) returns (stream ecsrelay.Message);
   */
  openStream(input: Signature, options?: RpcOptions): ServerStreamingCall<Signature, Message> {
    const method = this.methods[7],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<Signature, Message>("serverStreaming", this._transport, method, opt, input);
  }
  /**
   * Push a stream of messages to be relayed.
   *
   * @generated from protobuf rpc: PushStream(stream ecsrelay.PushRequest) returns (stream ecsrelay.PushResponse);
   */
  pushStream(options?: RpcOptions): DuplexStreamingCall<PushRequest, PushResponse> {
    const method = this.methods[8],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<PushRequest, PushResponse>("duplex", this._transport, method, opt);
  }
  /**
   * Push a single message to be relayed.
   *
   * @generated from protobuf rpc: Push(ecsrelay.PushRequest) returns (ecsrelay.PushResponse);
   */
  push(input: PushRequest, options?: RpcOptions): UnaryCall<PushRequest, PushResponse> {
    const method = this.methods[9],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<PushRequest, PushResponse>("unary", this._transport, method, opt, input);
  }
  /**
   * Push a series of messages to be relayed.
   *
   * @generated from protobuf rpc: PushMany(ecsrelay.PushManyRequest) returns (ecsrelay.PushResponse);
   */
  pushMany(input: PushManyRequest, options?: RpcOptions): UnaryCall<PushManyRequest, PushResponse> {
    const method = this.methods[10],
      opt = this._transport.mergeOptions(options);
    return stackIntercept<PushManyRequest, PushResponse>("unary", this._transport, method, opt, input);
  }
}
